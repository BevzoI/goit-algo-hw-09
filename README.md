# goit-algo-hw-09
Видача решти: Жадібний алгоритм vs Динамічне програмування
Опис завдання
Розроблена система для касового апарату, яка визначає оптимальний спосіб видачі решти покупцеві.
Підтримуються номінали монет: [50, 25, 10, 5, 2, 1].

Реалізовано дві функції:

find_coins_greedy(amount, coins=[50, 25, 10, 5, 2, 1])
Видає решту, використовуючи жадібний алгоритм (завжди обирає найбільший можливий номінал).

find_min_coins(amount, coins=[50, 25, 10, 5, 2, 1])
Використовує метод динамічного програмування для знаходження способу видачі решти з мінімальною кількістю монет.

Опис алгоритмів
Жадібний алгоритм (find_coins_greedy)
Стратегія: спочатку використовувати монети найбільшого номіналу.

Швидкість роботи: O(n), де n — кількість різних номіналів (константа).

Переваги: надзвичайно швидкий, дуже простий.

Недолік: не завжди гарантує мінімальну кількість монет для довільних наборів монет.

У нашому випадку працює оптимально, бо монетна система добре збалансована.

Динамічне програмування (find_min_coins)
Стратегія: для кожної можливої суми обчислює мінімальну кількість монет.

Швидкість роботи: O(amount × n), де amount — сума, n — кількість номіналів.

Переваги: завжди знаходить рішення з мінімальною кількістю монет.

Недолік: більше використання пам'яті та часу при великих сумах.

Висновки
Жадібний алгоритм є ідеальним вибором, коли:

Монетна система дозволяє завжди формувати мінімальну кількість монет.

Потрібна максимальна швидкість.

Потрібна мінімальна складність реалізації.

Алгоритм динамічного програмування потрібен, якщо:

Набір монет складний і можливе неочевидне мінімальне рішення.

Потрібно знайти абсолютно мінімальну кількість монет для будь-якої суми.

У реальних проєктах доцільно мати обидва підходи: для "швидкого шляху" і для "гарантовано оптимального шляху".